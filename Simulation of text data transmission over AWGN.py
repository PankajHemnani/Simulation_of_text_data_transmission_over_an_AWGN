# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iHyHrIsukkF7JS2G-_-mfgiGuY45qYuf

# IMPORTING LIBRARIES
"""

import numpy as np
import matplotlib.pyplot as plt

def v_xor(bit0,bit1):
    if(bit0==bit1):
        return '0'
    else:
        return '1'

"""# SOURCE ENCODING"""

try:
    test = open("test.txt","r")
except IOError:
    print("Please provide correct file path")
TextToBeEncoded = ""
for i in test.read():
  TextToBeEncoded = TextToBeEncoded + i

distinct=[]
list1=[]
list_dec=[]
for i in TextToBeEncoded:
    if i not in distinct:
        distinct.append(i)
    else:
        pass

for i in distinct:
    n=TextToBeEncoded.count(i)
    t=(i,n)
    list1.append(t)
print(list1)

list_sorted=sorted(list1, key=lambda y : y[1])

a=len(list1)
for i in range(a):       # Reversing the list to arrange in Decreasing order of no of occurence
    list_dec.append(list_sorted[a-i-1])

#print('\n\n----------------- FIXED LENGTH ENCODING PART-------------------------------------------------------------')
print("\n\nFixed length Coding")
index=0
Encode={}                              #Blank Dictionary
grey=''

for i in list_dec:                   #Encoding dictionary: Assigns 5 bit binary to each character in the text
    index+=1
    binary='{0:06b}'.format(index)
    Encode.update({i[0]:binary})
# for i in Encode:
    # print(i,Encode[i])
    
    #print(f'{i[0]}     \t\t{binary}     \t\t{grey}')
# print(Encode)     #------->Uncomment to see the codes
CodedWord = ''
print("\nCoded bits are---->")
for i in TextToBeEncoded:                                     # Encoding is done for the given string
    CodedWord = CodedWord + Encode.get(i)       
    
print(CodedWord)

"""# CHANNEL ENCODER"""

def viterbi_encoder(inputs):
    
    #shift register encoder
    s_reg = ['0','0','0']
    obs = []
    for i in range(len(inputs)):
        #shifting the bits to right
        s_reg[2]=s_reg[1]
        s_reg[1]=s_reg[0]
        #inserting input
        s_reg[0]= inputs[i]
        state = s_reg[0]+ s_reg[1]
        #encoded bits
        thisState = v_xor(v_xor(s_reg[0],s_reg[1]),s_reg[2])+ v_xor(s_reg[0],s_reg[2])
        obs.append(thisState)
       
        output = ''
        for sym in obs:
            output = output + sym
    return output
    
ChannelEncoded = viterbi_encoder(CodedWord)
print(f'Channel encoded signal ->\n{ChannelEncoded}')

"""# MODULATION"""

binbits=np.array([])
for i in ChannelEncoded:
  binbits=np.append(binbits,int(i))

bpskout = 2*binbits-1

"""# CHANNEL NOISE"""

AWGN = np.random.normal(0,0.25,len(binbits)) # be careful of the standard deviation
X = [x for x in range(len(binbits))]
plt.plot(X, AWGN)
plt.xlabel("Bits")
plt.ylabel("Noise to be added")
plt.title("Bits v/s Noise plot")
plt.show()

Txbits = bpskout
Rxbits = Txbits + AWGN

"""# DEMODULATION"""

Sxbits=[]
for i in Rxbits:
  if(i<=0):
    Sxbits.append(0)
  else:
    Sxbits.append(1)
print('Demodulated--->')
demodulated_data = ''.join([str(i) for i in Sxbits])
print(demodulated_data)

"""# CHANNEL DECODER"""

def hamming_distance(x, y):
    # determines hamming distancer between symbol x and symbol y 
    count = 0
    # assunption, x and y of same length
    for i in range(len(x)):
        if x[i] != y[i]:
            count += 1
    return count
  
def viterbi_decoder(code):
    result = ''
    A=''
    segmented_code=[]
    for i in range(0,len(code),2):
        A=A+str(code[i])+str(code[i+1])
        segmented_code.append(A)    
        A=''
    in_out_dict= {
        ('00', '00') : '00',
        ('00', '01') : '11',
        ('01', '10') : '10',
        ('01', '11') : '01',
        ('10', '00') : '10',
        ('10', '01') : '00',
        ('11', '10') : '01',
        ('11', '11') : '10',
    }
    all_possible_next_states = {
    '00' : ('00', '01'),
    '01' : ('10', '11'),
    '10' : ('00', '01'),
    '11' : ('10', '11')
    }
    first_state = '00'
    current_state = first_state
    for in_state in segmented_code:
        next_states = all_possible_next_states[current_state] # tupple of next possible states
        dist = [0, 0] # for storing hamming distance from next state to input_state
        for i in range(len(next_states)):
            # dist[i] = hamming_distance(in_state, next_states[i])
            dist[i] = hamming_distance(in_state, in_out_dict.get((current_state, next_states[i])))

        bit = str(np.argmin(dist)) # finds the correspoonding bit for the path with min hamming distance
        result = result + bit
        current_state = next_states[int(bit)] # saves the next current state for propagation in trellis diagram
    return result

channel_decoded = viterbi_decoder(demodulated_data)
print('Channel decoded --->')
print(channel_decoded)

"""# SOURCE DECODER"""

new= open("DecodedText.dat","w")

Decode = {value:key for key, value in Encode.items()}
result = ''
for i in range(0, len(channel_decoded), 6):
    symbol = channel_decoded[i:i+6]
    # print(symbol) # debug
    # print(Decode.get(symbol, '#'))
    new.write(Decode.get(symbol, '#'))
    result = result + Decode.get(symbol, '#')
print("Final Decoded signal: ")
print(result)

"""# RESULT"""

Wrongdetection = 0
for i in range(len(channel_decoded)):
  if(channel_decoded[i]!=CodedWord[i]):
    Wrongdetection += 1
print("Incorrect Detection: ",Wrongdetection)